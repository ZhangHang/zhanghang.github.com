
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>JOS 实验一</title>
    
    <meta name="author" content="ZH">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="/assets/themes/twitter/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="/assets/themes/twitter/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">

    <!-- Le fav and touch icons -->
  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->
  </head>

  <body>

    <div class="navbar">
      <div class="navbar-inner">
        <div class="container">
          <a class="brand" href="/">ZH</a>
          <ul class="nav">
            
            
            


  
    
      
      	
      	<li><a href="/archive.html">Archive</a></li>
      	
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/categories.html">Categories</a></li>
      	
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/pages.html">Pages</a></li>
      	
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/tags.html">Tags</a></li>
      	
      
    
  



          </ul>
        </div>
      </div>
    </div>

    <div class="container">

      <div class="content">
        
<div class="page-header">
  <h1>JOS 实验一 <small></small></h1>
</div>

<div class="row">
  <div class="span8">
    
		<ol>
			<li>Part 1: PC BootStrap</li>
		</ol><h4>Exercise 1</h4>
<p>Familiarize yourself with the assembly language materials available on <a href="http://pdos.csail.mit.edu/6.828/2012/reference.html">the 6.828 reference page</a> . You don&#8217;t have to read them now, but you&#8217;ll almost certainly want to refer to some of this material when reading and writing x86 assembly.</p>
<p>We do recommend reading the section &#8220;The Syntax&#8221; in <a href="http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html">Brennan&#8217;s Guide to Inline Assembly</a> . It gives a good (and quite brief) description of the AT&amp;T assembly syntax we&#8217;ll be using with the <span class="caps">GNU</span> assembler in <span class="caps">JOS</span>.</p>
<h4>Exercise 2</h4>
<p>Use GDB&#8217;s si (Step Instruction) command to trace into the <span class="caps">ROM</span> <span class="caps">BIOS</span> for a few more instructions, and try to guess what it might be doing.You might want to look at <a href="http://web.archive.org/web/20040404164813/members.iweb.net.au/~pstorr/pcbook/book2/book2.htm">Phil Storrs I/O Ports Description</a> , as well as other materials on the <a href="http://pdos.csail.mit.edu/6.828/2012/reference.html">6.828 reference materials page</a> . No need to figure out all the details &#8211; just the general idea of what the <span class="caps">BIOS</span> is doing first.</p>
<h3>Part 2: The Boot Loader</h3>
<h4>Exercise 3</h4>
<p>Take a look at the lab tools guide, especially the section on <span class="caps">GDB</span> commands. Even if you&#8217;re familiar with <span class="caps">GDB</span>, this includes some esoteric <span class="caps">GDB</span> commands that are useful for OS work.</p>
<p>Set a breakpoint at address 0&#215;7c00, which is where the boot sector will be loaded. Continue execution until that breakpoint. Trace through the code in boot/boot.S, using the source code and the disassembly file obj/boot/boot.asm to keep track of where you are. Also use the x/i command in <span class="caps">GDB</span> to disassemble sequences of instructions in the boot loader, and compare the original boot loader source code with both the disassembly in obj/boot/boot.asm and <span class="caps">GDB</span>.</p>
<p>Trace into bootmain() in boot/main.c, and then into readsect(). Identify the exact assembly instructions that correspond to each of the statements in readsect(). Trace through the rest of readsect() and back out into bootmain(), and identify the begin and end of the for loop that reads the remaining sectors of the kernel from the disk. Find out what code will run when the loop is finished, set a breakpoint there, and continue to that breakpoint. Then step through the remainder of the boot loader.</p>
<hr />
<p>在一切开始之前，我们要弄懂如何调用 gdb 调试运行在 qemu 虚拟的计算机中的系统。</p>
<p>资料上说运行</p>
<pre>
make qemu-gdb
</pre>
<p>那么 make 是什么？为什么 qemu-gdb 作为参数就可以调试了？</p>
<pre>
Make gets its knowledge of how to build your program from a file called the makefile, which lists each of the non-source files and how to compute it from other files. When you write a program, you should write a makefile for it, so that it is possible to use Make to build and install the program
</pre>
<p>make 是个按照规则执行批处理操作的工具。</p>
<p><span class="caps">JOS</span> 中规则文件叫 GNUmakefile，其中定义了编译、调用虚拟机、调试相关的规则，下面列出对我们这次实验有用的参数</p>
<ul>
	<li>make ``编译 <span class="caps">JOS</span>``</li>
	<li>make qemu ``调用配置 qemu 载入 <span class="caps">JOS</span> 镜像``</li>
	<li>make qemu-gdb ``调用配置 qemu 载入 <span class="caps">JOS</span> 镜像并连接 <span class="caps">GDB</span> 供调试``</li>
</ul>
<p>问题弄懂后开始实践，切换到JOS源代码目录</p>
<pre>
make qemu-gdb
</pre>
<p>打开另一个终端，运行 gdb</p>
<p><img src="/assets/images/jos_gdb.png" maxwidth=700></p>
<p>然后一个新终端，运行 gdb 就可以开始调试了，我们可以运行很多命令，比如：</p>
<p>在 0&#215;7c00 处下断点</p>
<pre>
b *0x7c00
</pre>
<p>继续运行</p>
<pre>
c
</pre>
<p>下一步</p>
<pre>
si
</pre>
<hr />
<p>Be able to answer the following questions:</p>
<ul>
	<li>At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode?</li>
	<li>What is the last instruction of the boot loader executed, and what is the first instruction of the kernel it just loaded?</li>
	<li>Where is the first instruction of the kernel?</li>
	<li>How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?</li>
</ul>
<p>1. <span class="caps">CPU</span> 中有个寄存器叫 CR0，它 <a href="http://en.wikipedia.org/wiki/Control_register#CR0">每一位都是个标示符</a> ，其中第 0 位用来标识 <span class="caps">CPU</span> 是运行在实时模式还是保护模式。所以从头开始找到修改 <span class="caps">CRO</span> 第 0 位的代码也就找到了使 <span class="caps">CPU</span> 切换到 32 位的代码。</p>
<p>计算机在启动后会调用 BIOS，它做完基础的系统初始化工作，比如检查内存容量后会把启动分区第一扇区的 bootloader 读到内存 0&#215;7c00 处，交给 bootloader 控制权，执行它。</p>
<p><span class="caps">JOS</span> 的 bootloader 由 /boot/boot.s 和 /boot/mian.c 两部分组成，当执行 bootloader 时首先运行的是 boot.s ，所以我们从这里开始看。</p>
<p>找到</p>
<div class="highlight"><pre><code class="gas"><span class="c"># Switch from real to protected mode, using a bootstrap GDT</span>
<span class="c"># and segment translation that makes virtual addresses </span>
<span class="c"># identical to their physical addresses, so that the </span>
<span class="c"># effective memory map does not change during the switch.</span>
<span class="nf">lgdt</span>    <span class="no">gdtdesc</span>
<span class="nf">movl</span>    <span class="nv">%cr0</span><span class="p">,</span> <span class="nv">%eax</span>
<span class="nf">orl</span>     <span class="no">$CR0_PE_ON</span><span class="p">,</span> <span class="nv">%eax</span>
<span class="nf">movl</span>    <span class="nv">%eax</span><span class="p">,</span> <span class="nv">%cr0</span>

<span class="c"># Jump to next instruction, but in 32-bit code segment.</span>
<span class="c"># Switches processor into 32-bit mode.</span>
<span class="nf">ljmp</span>    <span class="no">$PROT_MODE_CSEG</span><span class="p">,</span> <span class="no">$protcseg</span>
</code></pre>
</div>
<p>往前看到</p>
<div class="highlight"><pre><code class="gas"><span class="na">.set</span> <span class="no">CR0_PE_ON</span><span class="p">,</span>      <span class="mi">0x1</span>         <span class="c"># protected mode enable flag</span>
</code></pre>
</div>
<p>这就是把 CR0 的 0 位改为 1 ，使 <span class="caps">CPU</span> 切换到 32 位保护模式的地方。</p>
<p>2.阅读 boot.s 发现在最后它去运行了 main.c 中的 bootmain</p>
<div class="highlight"><pre><code class="gas"><span class="c"># Set up the stack pointer and call into C.</span>
<span class="nf">movl</span>    <span class="no">$start</span><span class="p">,</span> <span class="nv">%esp</span>
<span class="nf">call</span> <span class="no">bootmain</span>
</code></pre>
</div>
<p>bootmain，最后一行代码即 bootloader 最后一行代码</p>
<div class="highlight"><pre><code class="c"><span class="c1">// call the entry point from the ELF header</span>
<span class="c1">// note: does not return!</span>
<span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span> <span class="p">(</span><span class="n">ELFHDR</span><span class="o">-&gt;</span><span class="n">e_entry</span><span class="p">))();</span>
</code></pre>
</div>
<p>整个 bootmain 做的事情就是把 <span class="caps">ELF</span> 格式的内核镜像载入内存，然后去叫内核的入口，ELF 格式的详细信息前面的资料有。</p>
<p>这时我们可以说 bootloader 最后一行代码就是去执行 e_entry 启动内核。</p>
<p>那么内核第一句执行的是什么？<br />
先看 main.c</p>
<div class="highlight"><pre><code class="c"><span class="cp">#define ELFHDR		((struct Elf *) 0x10000) </span><span class="c1">// scratch space</span>
</code></pre>
</div>
<p>内核从内存 0&#215;10000 开始。</p>
<p>但</p>
<pre>
objdump -x obj/kern/kernel
</pre>
<p>看到</p>
<pre>
SYMBOL TABLEL
f0100000 l     d .text 00000000 .text
f010000c g       .text 00000000 entry
</pre>
<p>0xf01000c &#8211; (0xf0100000 &#8211; 0&#215;00100000) = 0&#215;0010000c 就是内核入口地址。</p>
<p><img src="/assets/images/jos_kernel_entry.png" maxwidth=700></p>
<p>内核执行的第一句代码是</p>
<div class="highlight"><pre><code class="gas"><span class="nf">movw</span>    <span class="no">$0x1234</span><span class="p">,</span> <span class="mi">0x472</span>
</code></pre>
</div>
<p>3. 内核第一句话在 obj/kern/Kernel.asm 中</p>
<div class="highlight"><pre><code class="gas"><span class="nl">entry:</span>
        <span class="nf">movw</span>    <span class="no">$0x1234</span><span class="p">,</span> <span class="mi">0x472</span>     <span class="c">#warm boot</span>
</code></pre>
</div>
<p>4.这个操作系统老实说 <span class="caps">ELF</span> 这种格式决定了所有关于 sector 的信息都存在文件头了，bootmain 中把读入的头转换成了 Proghdr，里面就是 sector 的信息，具体以后添加。</p>
<h4>Exercise 4</h4>
<p>Read about programming with pointers in C. The best reference for the C language is The C Programming Language by Brian Kernighan and Dennis Ritchie (known as &#8216;K&amp;R&#8217;). We recommend that students purchase this book (here is an <a href="http://www.amazon.com/C-Programming-Language-2nd/dp/0131103628/sr=8-1/qid=1157812738/ref=pd_bbs_1/104-1502762-1803102?ie=UTF8&amp;s=books">Amazon Link</a> ) or find one of <a href="http://library.mit.edu/F/AI9Y4SJ2L5ELEE2TAQUAAR44XV5RTTQHE47P9MKP5GQDLR9A8X-10422?func=item-global&amp;doc_library=MIT01&amp;doc_number=000355242&amp;year=&amp;volume=&amp;sub_library">MIT&#8217;s 7 copies</a>= .</p>
<p>Read 5.1 (Pointers and Addresses) through 5.5 (Character Pointers and Functions) in K&amp;R. Then download the code for <a href="http://pdos.csail.mit.edu/6.828/2012/labs/lab1/pointers.c">pointers.c</a> , run it, and make sure you understand where all of the printed values come from. In particular, make sure you understand where the pointer addresses in lines 1 and 6 come from, how all the values in lines 2 through 4 get there, and why the values printed in line 5 are seemingly corrupted.</p>
<p>There are other references on pointers in C, though not as strongly recommended. <a href="http://pdos.csail.mit.edu/6.828/2012/readings/pointers.pdf">A tutorial by Ted Jensen</a> that cites K&amp;R heavily is available in the course readings.</p>
<p>Warning: Unless you are already thoroughly versed in C, do not skip or even skim this reading exercise. If you do not really understand pointers in C, you will suffer untold pain and misery in subsequent labs, and then eventually come to understand them the hard way. Trust us; you don&#8217;t want to find out what &#8220;the hard way&#8221; is.</p>
<div class="highlight"><pre><code class="c"><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>

<span class="kt">void</span>
<span class="nf">f</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;1: a = %p, b = %p, c = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>

    <span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;2: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	   <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>

    <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">300</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="mi">301</span><span class="p">;</span>
    <span class="mi">3</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">302</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;3: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	   <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>

    <span class="n">c</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="mi">400</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;4: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	   <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>

    <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="mi">500</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;5: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	   <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>

    <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;6: a = %p, b = %p, c = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">ac</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">av</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>
<p>输出结果为</p>
<pre>
1: a = 0x7fff5e0fe4c0, b = 0x7fca114000e0, c = 0x7fff61701740
2: a[ 0 ] = 200, a[ 1 ] = 101, a[ 2 ] = 102, a[ 3 ] = 103
3: a[ 0 ] = 200, a[ 1 ] = 300, a[ 2 ] = 301, a[ 3 ] = 302
4: a[ 0 ] = 200, a[ 1 ] = 400, a[ 2 ] = 301, a[ 3 ] = 302
5: a[ 0 ] = 200, a[ 1 ] = 128144, a[ 2 ] = 256, a[ 3 ] = 302
6: a = 0x7fff5e0fe4c0, b = 0x7fff5e0fe4c4, c = 0x7fff5e0fe4c1
</pre>
<p>其中</p>
<div class="highlight"><pre><code class="c"><span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</code></pre>
</div>
<p>每个 int 占用 4 字节，而 char 占 1 字节，所以 （char *）a + 1 的结果为 a 后的 1 字节，再（int *）后，c 为指向由 a[ 0 ] 后 3 字节与 a[ 1 ] 组成的 int 的指针。</p>
<p>观察</p>
<pre>
6: a = 0x7fff5e0fe4c0, b = 0x7fff5e0fe4c4, c = 0x7fff5e0fe4c1
</pre>
<p>结论得证。</p>
<h4>Exercise 5</h4>
<p>Trace through the first few instructions of the boot loader again and identify the first instruction that would &#8220;break&#8221; or otherwise do the wrong thing if you were to get the boot loader&#8217;s link address wrong. Then change the link address in boot/Makefrag to something wrong, run make clean, recompile the lab with make, and trace into the boot loader again to see what happens. Don&#8217;t forget to change the link address back and make clean again afterward!</p>
<h4>Exercise 6</h4>
<p>We can examine memory using GDB&#8217;s x command. The <span class="caps">GDB</span> manual has full details, but for now, it is enough to know that the command <strong>x/Nx <span class="caps">ADDR</span></strong> prints N words of memory at <strong><span class="caps">ADDR</span></strong> . (Note that both &#8217;x&#8217;s in the command are lowercase.) Warning: The size of a word is not a universal standard. In <span class="caps">GNU</span> assembly, a word is two bytes (the &#8216;w&#8217; in xorw, which stands for word, means 2 bytes).</p>
<p>Reset the machine (exit <span class="caps">QEMU</span>/<span class="caps">GDB</span> and start them again). Examine the 8 words of memory at 0&#215;00100000 at the point the <span class="caps">BIOS</span> enters the boot loader, and then again at the point the boot loader enters the kernel. Why are they different? What is there at the second breakpoint? (You do not really need to use <span class="caps">QEMU</span> to answer this question. Just think.)</p>
<p><span class="caps">BIOS</span> 刚进入 boot loader 时，内存里只有 从 0&#215;7c00 开始的 boot loader，它有（待填）大，0x00100000 空，boot loader 执行完把内核载入到从 0&#215;10000 开始的地方，0x00100000 区域被用来放内核了，里面内容不再为空。Easy？</p>
<h3>Part 3: The Kernel</h3>
<h4>Exercise 7</h4>
<p>Use <span class="caps">QEMU</span> and <span class="caps">GDB</span> to trace into the <span class="caps">JOS</span> kernel and stop at the movl %eax, %cr0. Examine memory at 0&#215;00100000 and at 0xf0100000. Now, single step over that instruction using the stepi <span class="caps">GDB</span> command. Again, examine memory at 0&#215;00100000 and at 0xf0100000. Make sure you understand what just happened.</p>
<p>What is the first instruction after the new mapping is established that would fail to work properly if the mapping weren&#8217;t in place? Comment out the movl %eax, %cr0 in kern/entry.S, trace into it, and see if you were right.</p>
<div class="highlight"><pre><code class="gas"><span class="err">%</span><span class="nf">eax</span><span class="p">,</span> <span class="nv">%cr0</span> 
</code></pre>
</div>
<p>后启用了虚拟地址转换，然后 0xf0100000 就被映射成 0&#215;0010000，所以都一样了。</p>
<h4>Exercise 8</h4>
<p>We have omitted a small fragment of code &#8211; the code necessary to print octal numbers using patterns of the form &#8220;%o&#8221;. Find and fill in this code fragment.</p>
<p>终于开始要写代码了，第一个问题非常简单，找到 printfmt.c 中的 vprintfmt 函数</p>
<div class="highlight"><pre><code class="c"><span class="kt">void</span> <span class="n">vprintfmt</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">putch</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">putdat</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">ap</span><span class="p">)</span>
</code></pre>
</div>
<p>里面处理了各种参数，很好玩的是，这个函数的实现用了 goto 语句，找到 case &#8220;o&#8221; ，这就是 8 进制相关的代码，照猫画虎，改成:</p>
<div class="highlight"><pre><code class="c"><span class="k">case</span> <span class="sc">&#39;o&#39;</span>:
	<span class="n">num</span> <span class="o">=</span> <span class="n">getuint</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="p">,</span> <span class="n">lflag</span><span class="p">);</span>
	<span class="n">base</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">number</span><span class="p">;</span>
</code></pre>
</div>
<p>好了，我们的 print 函数升级了，重新运行 JOS，不开 debug，输出如下：</p>
<p><img src="/assets/images/print_o.png" maxwidth=700></p>
<pre>
6828 decimal is 15254 octal!
</pre>
<p>Be able to answer the following questions:</p>
<p>1. Explain the interface between printf.c and console.c. Specifically, what function does console.c export? How is this function used by printf.c?</p>
<p>printf.c 中的</p>
<div class="highlight"><pre><code class="c"><span class="k">static</span> <span class="kt">void</span>
<span class="nf">putch</span><span class="p">(</span><span class="kt">int</span> <span class="n">ch</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cputchar</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
	<span class="o">*</span><span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>
<p>调用了 console.c 中的 putch，它的功能就是和硬件打交道打印一个字符</p>
<div class="highlight"><pre><code class="c"><span class="c1">// output a character to the console</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cons_putc</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">serial_putc</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">lpt_putc</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">cga_putc</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>
<p>2. Explain the following from console.c:</p>
<div class="highlight"><pre><code class="c"><span class="k">if</span> <span class="p">(</span><span class="n">crt_pos</span> <span class="o">&gt;=</span> <span class="n">CRT_SIZE</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">crt_buf</span><span class="p">,</span> <span class="n">crt_buf</span> <span class="o">+</span> <span class="n">CRT_COLS</span><span class="p">,</span> <span class="p">(</span><span class="n">CRT_SIZE</span> <span class="o">-</span> <span class="n">CRT_COLS</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">));</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">CRT_SIZE</span> <span class="o">-</span> <span class="n">CRT_COLS</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CRT_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">crt_buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0700</span> <span class="o">|</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
        <span class="n">crt_pos</span> <span class="o">-=</span> <span class="n">CRT_COLS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>
<p>3. For the following questions you might wish to consult the notes for Lecture 2. These notes cover GCC&#8217;s calling convention on the x86.<br />
Trace the execution of the following code step-by-step:</p>
<div class="highlight"><pre><code class="c"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="n">cprintf</span><span class="p">(</span><span class="s">&quot;x %d, y %x, z %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
</code></pre>
</div>
<ul>
	<li>In the call to cprintf(), to what does fmt point? To what does ap point?</li>
	<li>List (in order of execution) each call to cons_putc, va_arg, and vcprintf. For cons_putc, list its argument as well. For va_arg, list what ap points to before and after the call. For vcprintf list the values of its two arguments.</li>
</ul>
<p>fmt 指向 &#8220;x %d, y %x, z %d\n&#8221; 的头，也就是&quot; &quot; &quot;，ap指向 xyz 所组成内存区域的头， 也就是 x。</p>
<p>4. Run the following code.</p>
<div class="highlight"><pre><code class="c"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mh">0x00646c72</span><span class="p">;</span>
<span class="n">cprintf</span><span class="p">(</span><span class="s">&quot;H%x Wo%s&quot;</span><span class="p">,</span> <span class="mi">57616</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
</code></pre>
</div>
<p>What is the output? Explain how this output is arrived at in the step-by-step manner of the previous exercise. Here&#8217;s an <span class="caps">ASCII</span> table that maps bytes to characters.<br />
The output depends on that fact that the x86 is little-endian. If the x86 were instead big-endian what would you set i to in order to yield the same output? Would you need to change 57616 to a different value?</p>
<p>Here&#8217;s a description of little- and big-endian and a more whimsical description.</p>
<p>得到打印结果是</p>
<pre>
He110 World!
</pre>
<p>根据 <span class="caps">ASSIC</span> 表查到 0&#215;00646c72 对应：</p>
<pre>
d     100 0144 0x64
l     108 0154 0x6c
r     114 0162 0x72
(nul)   0 0000 0x00
</pre>
<p>57616 十六进制对应:</p>
<pre>
e11
</pre>
<p>看对应结果知道我们的机器是 big-endian.</p>
<p>5. In the following code, what is going to be printed after &#8216;y=&#8217;? (note: the answer is not a specific value.) Why does this happen?</p>
<div class="highlight"><pre><code class="c"><span class="n">cprintf</span><span class="p">(</span><span class="s">&quot;x=%d y=%d&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</code></pre>
</div>
<p>当 printfmt 的 ap 去找 y 的时候，那块内存区域没有被正确赋值，所以内容不是我们想要的。</p>
<p>6. Let&#8217;s say that <span class="caps">GCC</span> changed its calling convention so that it pushed arguments on the stack in declaration order, so that the last argument is pushed last. How would you have to change cprintf or its interface so that it would still be possible to pass it a variable number of arguments?</p>
<h3>The Stack</h3>
<h4>Exercise 9</h4>
<p>Determine where the kernel initializes its stack, and exactly where in memory its stack is located. How does the kernel reserve space for its stack? And at which &#8220;end&#8221; of this reserved area is the stack pointer initialized to point to?</p>
<p>entry.S 中 stack 初值被设置为空指针 0&#215;0</p>
<div class="highlight"><pre><code class="gas"><span class="c"># Clear the frame pointer register (EBP)</span>
<span class="c"># so that once we get into debugging C code,</span>
<span class="c"># stack backtraces will be terminated properly.</span>
<span class="nf">movl</span>    <span class="no">$0x0</span><span class="p">,</span><span class="nv">%ebp</span>           <span class="c"># nuke frame pointer</span>

<span class="c"># Set the stack pointer</span>
<span class="nf">movl</span>    <span class="no">$</span><span class="p">(</span><span class="no">bootstacktop</span><span class="p">),</span><span class="nv">%esp</span>

<span class="c"># now to C code</span>
<span class="nf">call</span>    <span class="no">i386_init</span>
</code></pre>
</div>
<p>再看定义：</p>
<div class="highlight"><pre><code class="gas"><span class="na">.data</span>
<span class="c">###################################################################</span>
<span class="c"># boot stack</span>
<span class="c">###################################################################</span>
    <span class="na">.p2align</span>    <span class="no">PGSHIFT</span>     <span class="c"># force page alignment</span>
    <span class="na">.globl</span>      <span class="no">bootstack</span>
<span class="nl">bootstack:</span>
    <span class="na">.space</span>      <span class="no">KSTKSIZE</span>
    <span class="na">.globl</span>      <span class="no">bootstacktop</span>   
<span class="no">bootstacktop</span><span class="p">:</span>
</code></pre>
</div>
<p>stack 大小 <span class="caps">KSTKSIZE</span> (32KB)，栈低就是 bootstacktop。</p>
<h4>Exercise 10</h4>
<p>To become familiar with the C calling conventions on the x86, find the address of the test_backtrace function in obj/kern/kernel.asm, set a breakpoint there, and examine what happens each time it gets called after the kernel starts. How many 32-bit words does each recursive nesting level of test_backtrace push on the stack, and what are those words?<br />
Note that, for this exercise to work properly, you should be using the patched version of <span class="caps">QEMU</span> available on the tools page or on Athena. Otherwise, you&#8217;ll have to manually translate all breakpoint and memory addresses to linear addresses.</p>
<p>这个在北京大学 <span class="caps">JOS</span> 实验一中说的很清楚了，共 32bit 被压入栈中。</p>
<h4>Exercise 11</h4>
<p>Implement the backtrace function as specified above. Use the same format as in the example, since otherwise the grading script will be confused. When you think you have it working right, run make grade to see if its output conforms to what our grading script expects, and fix it if it doesn&#8217;t. After you have handed in your Lab 1 code, you are welcome to change the output format of the backtrace function any way you like.</p>
<h4>Exercise 12</h4>
<p>Modify your stack backtrace function to display, for each eip, the function name, source file name, and line number corresponding to that eip.<br />
In debuginfo_eip, where do __STAB_* come from? This question has a long answer; to help you to discover the answer, here are some things you might want to do:</p>
<pre>
look in the file kern/kernel.ld for __STAB_*
run i386-jos-elf-objdump -h obj/kern/kernel
run i386-jos-elf-objdump -G obj/kern/kernel
run i386-jos-elf-gcc -pipe -nostdinc -O2 -fno-builtin -I. -MD -Wall -Wno- format -DJOS_KERNEL -gstabs -c -S kern/init.c, and look at init.s.
see if the bootloader loads the symbol table in memory as part of loading the kernel binary
Complete the implementation of debuginfo_eip by inserting the call to stab_binsearch to find the line number for an address.
Add a backtrace command to the kernel monitor, and extend your implementation of mon_backtrace to call debuginfo_eip and print a line for each stack frame of the form:

K&gt; backtrace
Stack backtrace:
  ebp f010ff78  eip f01008ae  args 00000001 f010ff8c 00000000 f0110580 00000000
         kern/monitor.c:143: monitor+106
  ebp f010ffd8  eip f0100193  args 00000000 00001aac 00000660 00000000 00000000
         kern/init.c:49: i386_init+59
  ebp f010fff8  eip f010003d  args 00000000 00000000 0000ffff 10cf9a00 0000ffff
         kern/entry.S:70: &lt;unknown&gt;+0
K&gt;
</pre>
<p>Each line gives the file name and line within that file of the stack frame&#8217;s eip, followed by the name of the function and the offset of the eip from the first instruction of the function (e.g., monitor+106 means the return eip is 106 bytes past the beginning of monitor).<br />
Be sure to print the file and function names on a separate line, to avoid confusing the grading script.<br />
Tip: printf format strings provide an easy, albeit obscure, way to print non-null-terminated strings like those in ST <span class="caps">ABS</span> tables. printf(&#8220;%.*s&#8221;, length, string) prints at most length characters of string. Take a look at the printf man page to find out why this works.<br />
You may find that some functions are missing from the backtrace. For example, you will probably see a call to monitor() but not to runcmd(). This is because the compiler in-lines some function calls. Other optimizations may cause you to see unexpected line numbers. If you get rid of the -O2 from GNUMakefile, the backtraces may make more sense (but your kernel will run more slowly).<br />
￼￼￼</p>
<p>两个练习合起来一起做:</p>
<p>eip_debuginfo 中实现查找行数的代码，具体为什么这么实现，实际上我就是按照代码注释说的逻辑翻译成代码。</p>
<div class="highlight"><pre><code class="c">  <span class="n">stab_binsearch</span><span class="p">(</span><span class="n">stabs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lline</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rline</span><span class="p">,</span> <span class="n">N_SLINE</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">lline</span> <span class="o">&gt;</span> <span class="n">rline</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">info</span><span class="p">.</span><span class="n">eip_line</span> <span class="o">=</span>  <span class="n">stabs</span><span class="p">[</span><span class="n">rline</span><span class="p">].</span><span class="n">n_desc</span><span class="p">;</span>
</code></pre>
</div>
<p>￼</p>
<p>在终端中加入 backrace 命令：</p>
<div class="highlight"><pre><code class="c"><span class="k">static</span> <span class="k">struct</span> <span class="n">Command</span> <span class="n">commands</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span> <span class="s">&quot;help&quot;</span><span class="p">,</span> <span class="s">&quot;Display this list of commands&quot;</span><span class="p">,</span> <span class="n">mon_help</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s">&quot;kerninfo&quot;</span><span class="p">,</span> <span class="s">&quot;Display information about the kernel&quot;</span><span class="p">,</span> <span class="n">mon_kerninfo</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s">&quot;backtrace&quot;</span><span class="p">,</span> <span class="s">&quot;Display function stack one line at a time&quot;</span><span class="p">,</span><span class="n">mon_backtrace</span><span class="p">},</span>
<span class="p">};</span>
</code></pre>
</div>
<p>￼</p>
<p>弄明白 debuginfo_eip ，利用它实现 mon_backtrace：</p>
<div class="highlight"><pre><code class="c"><span class="kt">int</span>
<span class="nf">mon_backtrace</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">Trapframe</span> <span class="o">*</span><span class="n">tf</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">ebp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)</span><span class="n">read_ebp</span><span class="p">();</span>
    <span class="k">struct</span> <span class="n">Eipdebuginfo</span> <span class="n">info</span><span class="p">;</span>

    <span class="n">cprintf</span> <span class="p">(</span><span class="s">&quot;Stack backtrace:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">ebp</span> <span class="o">!=</span> <span class="mh">0x0</span><span class="p">){</span>
        <span class="n">cprintf</span> <span class="p">(</span><span class="s">&quot; ebp %08x eip %08x args %08x %08x %08x %08x %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ebp</span><span class="p">,</span> <span class="n">ebp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                 <span class="p">,</span> <span class="n">ebp</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">ebp</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">ebp</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">ebp</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">ebp</span><span class="p">[</span><span class="mi">6</span><span class="p">]);</span>

        <span class="n">debuginfo_eip</span><span class="p">(</span><span class="n">ebp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>    
        <span class="n">cprintf</span> <span class="p">(</span><span class="s">&quot;%s:%d: %.*s+%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">info</span><span class="p">.</span><span class="n">eip_file</span>
                    <span class="p">,</span><span class="n">info</span><span class="p">.</span><span class="n">eip_line</span>
                    <span class="p">,</span><span class="n">info</span><span class="p">.</span><span class="n">eip_fn_namelen</span><span class="p">,</span><span class="n">info</span><span class="p">.</span><span class="n">eip_fn_name</span>
                    <span class="p">,</span><span class="n">ebp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">info</span><span class="p">.</span><span class="n">eip_fn_addr</span><span class="p">);</span>

        <span class="n">ebp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)</span> <span class="n">ebp</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">}</span>
<span class="err">￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>
<p>好了，这时候运行 :</p>
<pre>
make grade
</pre>
<p><img src="/assets/images/lab1_grade.png" maxwidth=700></p>
<p>实验一完成。</p>
    <hr>
    <div class="pagination">
      <ul>
      
        <li class="prev"><a href="/dev/2012/10/13/JOS-Intro" title="学操作系统">&larr; Previous</a></li>
      
        <li><a href="/archive.html">Archive</a></li>
      
        <li class="next"><a href="/life/2012/11/18/mandelbrot-set" title="Mandelbrot Set">Next &rarr;</a></li>
      
      </ul>
    </div>
    <hr>
    
  </div>
  
  <div class="span4">
    <h4>Published</h4>
    <div class="date"><span>15 October 2012</span></div>

  
    <h4>Tags</h4>
    <ul class="tag_box">
    
    


  
     
    	<li><a href="/tags.html#JOS-ref">JOS <span>1</span></a></li>
     
    	<li><a href="/tags.html#OS-ref">OS <span>1</span></a></li>
    
  



    </ul>
    
  </div>
</div>


      </div>

      <footer>
        <p>&copy; ZH 2012 
          with help from <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
          and <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a>
        </p>
      </footer>

    </div> <!-- /container -->

    
  </body>
</html>

